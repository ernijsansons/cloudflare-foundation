/**
 * generate-scaffold.ts
 *
 * Populates the planning-machine scaffold files from real planning run data.
 * Run after a planning run completes to generate:
 *   - BOOTSTRAP.md (from tech-arch: service names, wrangler config)
 *   - DATA_MODEL.md (from tech-arch + product-design: entity definitions)
 *   - EXECUTION_RULES.md (from intake + tech-arch: product-specific Claude Code rules)
 *   - PRODUCT_ARCHITECTURE.md (from tech-arch: real service names, D1 names, worker names)
 *   - TASKS.json (from task-reconciliation: already generated by Phase 16)
 *
 * Usage:
 *   npx tsx planning-machine/scripts/generate-scaffold.ts <RUN_ID> [--output-dir <dir>]
 *
 * The script fetches phase artifacts from the planning machine API.
 * Set PLANNING_API_URL env var (default: http://localhost:8788)
 */

import * as fs from "fs";
import * as path from "path";

const PLANNING_API_URL = process.env["PLANNING_API_URL"] ?? "http://localhost:8788";
const runId = process.argv[2];
const outputDirFlag = process.argv.indexOf("--output-dir");
const outputDir =
  outputDirFlag !== -1 && process.argv[outputDirFlag + 1]
    ? process.argv[outputDirFlag + 1]!
    : path.join(process.cwd(), "planning-machine", "output", runId ?? "unknown");

if (!runId) {
  console.error("Usage: npx tsx planning-machine/scripts/generate-scaffold.ts <RUN_ID>");
  process.exit(1);
}

async function fetchArtifact(phase: string): Promise<Record<string, unknown> | null> {
  const url = `${PLANNING_API_URL}/api/planning/runs/${runId}/artifacts/${phase}`;
  const res = await fetch(url, {
    headers: { Authorization: `Bearer ${process.env["FOUNDATION_API_KEY"] ?? "dev"}` },
  });
  if (!res.ok) {
    console.warn(`[scaffold] Could not fetch ${phase} artifact: ${res.status}`);
    return null;
  }
  const data = await res.json() as { content?: string };
  if (!data.content) return null;
  try {
    return JSON.parse(data.content) as Record<string, unknown>;
  } catch {
    return null;
  }
}

function stringify(v: unknown): string {
  return typeof v === "string" ? v : JSON.stringify(v ?? {}, null, 2);
}

async function main() {
  console.log(`[scaffold] Generating scaffold for run: ${runId}`);

  fs.mkdirSync(outputDir, { recursive: true });

  // Fetch required artifacts
  const [techArch, productDesign, tasksOutput, intake] = await Promise.all([
    fetchArtifact("tech-arch"),
    fetchArtifact("product-design"),
    fetchArtifact("task-reconciliation"),
    fetchArtifact("__intake__"),
  ]);

  // ── BOOTSTRAP.md ──────────────────────────────────────────────────────────
  const serviceName = extractServiceName(techArch);
  const d1DatabaseName = extractD1Name(techArch) ?? `${serviceName}-primary`;
  const wranglerBindings = extractWranglerBindings(techArch);
  const bootstrapMd = `# Bootstrap — ${extractProjectName(productDesign)}

## Monorepo Structure

This project uses \`packages/*\` and \`services/*\` layout on the cloudflare-foundation-dev monorepo.

## Service Name

\`${serviceName}\`

## D1 Database

\`${d1DatabaseName}\`

## Wrangler Bindings

\`\`\`
${wranglerBindings}
\`\`\`

## Drizzle Schema

See DATA_MODEL.md for entity-storage map.

## Deploy Order

1. Run \`pnpm install\`
2. Run setup scripts: \`bash scripts/setup-all.sh\`
3. Apply migrations: \`wrangler d1 execute ${d1DatabaseName} --remote --file migrations/0000_init.sql\`
4. Deploy: \`pnpm run deploy\`
`;

  // ── DATA_MODEL.md ─────────────────────────────────────────────────────────
  const dbSchema = techArch?.databaseSchema ?? {};
  const mvpScope = productDesign?.mvpScope ?? {};
  const dataMd = `# Data Model — ${extractProjectName(productDesign)}

## Database: D1 (${d1DatabaseName})

### Entities from Tech Architecture

\`\`\`json
${stringify(dbSchema)}
\`\`\`

## MVP Scope (from Product Design)

\`\`\`json
${stringify(mvpScope)}
\`\`\`

## Entity-Storage Map

| Entity | Storage | Key Pattern |
|--------|---------|-------------|
| Tenant | D1 (tenants table) | id |
| User | D1 (users table) | id, tenant_id |
${extractEntityStorageMap(dbSchema)}

## Multi-Tenant Pattern

All tables use \`tenant_id\` for row-level tenant isolation.
All queries must include \`WHERE tenant_id = ?\` via tenantMiddleware().
`;

  // ── EXECUTION_RULES.md ────────────────────────────────────────────────────
  const techDecisions = techArch?.technicalDecisions as unknown[] ?? [];
  const envVars = techArch?.environmentVariables ?? {};
  const intakeConstraints = intake ?? {};
  const executionRulesMd = `# Execution Rules — ${extractProjectName(productDesign)}

## Product-Specific Claude Code Rules

### Tech Stack Constraints

${stringify(intakeConstraints)}

### Technical Decisions (from Tech Architecture Phase)

${techDecisions.map((d) => `- ${typeof d === "string" ? d : stringify(d)}`).join("\n")}

### Environment Variables Required

\`\`\`json
${stringify(envVars)}
\`\`\`

### Architecture Patterns (MANDATORY — follow exactly)

1. **All routes** use Hono in services/gateway/src/index.ts. Always add new routes there.
2. **Database queries** always use parameterized D1 prepared statements. No string interpolation.
3. **Authentication** uses authMiddleware() — apply to all /api/* routes.
4. **Tenant isolation** uses tenantMiddleware() — all queries bind tenant_id from context.
5. **File naming**: kebab-case (e.g., auth-service.ts). Functions: camelCase. DB columns: snake_case.
6. **Error handling**: always return c.json({ error: "message" }, statusCode) in Hono routes.
7. **TypeScript strict mode** is required. No \`any\` types in production code.
8. **Tests** go in \`__tests__\` subdirectories adjacent to the code they test.

### Service Boundaries

| Service | Location | Purpose |
|---------|----------|---------|
| Gateway (API) | services/gateway/ | All HTTP API routes |
| UI | services/ui/ | SvelteKit SSR frontend |
| Planning Machine | services/planning-machine/ | AI planning pipeline |
| Agents | services/agents/ | Durable Objects |
| Queues | services/queues/ | Queue consumers |

### What Not To Do

- Never import across service boundaries (e.g., from gateway in cron)
- Never use hardcoded IDs in wrangler.jsonc — use variables
- Never skip tenant isolation on DB queries
- Never expose raw error messages to the client
`;

  // ── PRODUCT_ARCHITECTURE.md ───────────────────────────────────────────────
  const apiRoutes = techArch?.apiRoutes ?? [];
  const sveltekitRoutes = techArch?.sveltekitRoutes ?? [];
  const durableObjects = techArch?.durableObjects ?? [];
  const productArchMd = `# Product Architecture — ${extractProjectName(productDesign)}

## Service Name: \`${serviceName}\`

## API Routes (services/gateway/)

\`\`\`json
${stringify(apiRoutes)}
\`\`\`

## SvelteKit Routes (services/ui/)

\`\`\`json
${stringify(sveltekitRoutes)}
\`\`\`

## Durable Objects (services/agents/)

\`\`\`json
${stringify(durableObjects)}
\`\`\`

## Cloudflare Services Used

${extractCloudflareServices(techArch)}
`;

  // Write all files
  fs.writeFileSync(path.join(outputDir, "BOOTSTRAP.md"), bootstrapMd);
  fs.writeFileSync(path.join(outputDir, "DATA_MODEL.md"), dataMd);
  fs.writeFileSync(path.join(outputDir, "EXECUTION_RULES.md"), executionRulesMd);
  fs.writeFileSync(path.join(outputDir, "PRODUCT_ARCHITECTURE.md"), productArchMd);

  // Copy TASKS.json if it was generated
  if (tasksOutput) {
    fs.writeFileSync(path.join(outputDir, "TASKS.json"), JSON.stringify(tasksOutput, null, 2));
    const summary = tasksOutput.summary as Record<string, unknown>;
    console.log(`[scaffold] TASKS.json: ${summary?.totalTasks ?? "?"} code tasks, ${summary?.totalMarketingTasks ?? "?"} marketing tasks`);
  } else {
    console.warn("[scaffold] No TASKS.json found — Phase 16 may not have completed yet");
    console.warn("[scaffold] Run /plan:tasks after the planning run completes");
  }

  console.log(`[scaffold] Scaffold generated at: ${outputDir}`);
  console.log(`[scaffold] Files: BOOTSTRAP.md, DATA_MODEL.md, EXECUTION_RULES.md, PRODUCT_ARCHITECTURE.md${tasksOutput ? ", TASKS.json" : ""}`);
}

// ── Helpers ──────────────────────────────────────────────────────────────────

function extractProjectName(productDesign: Record<string, unknown> | null): string {
  const mvpScope = productDesign?.mvpScope as Record<string, unknown> | undefined;
  return (mvpScope?.name as string) ?? (mvpScope?.productName as string) ?? "Your Product";
}

function extractServiceName(techArch: Record<string, unknown> | null): string {
  const wranglerChanges = techArch?.wranglerChanges as Record<string, unknown> | undefined;
  return (wranglerChanges?.serviceName as string) ?? "my-product";
}

function extractD1Name(techArch: Record<string, unknown> | null): string | null {
  const wranglerChanges = techArch?.wranglerChanges as Record<string, unknown> | undefined;
  return (wranglerChanges?.d1DatabaseName as string) ?? null;
}

function extractWranglerBindings(techArch: Record<string, unknown> | null): string {
  const wranglerChanges = techArch?.wranglerChanges as Record<string, unknown> | undefined;
  if (!wranglerChanges) return "# See wrangler.jsonc for binding configuration";
  return stringify(wranglerChanges);
}

function extractEntityStorageMap(dbSchema: unknown): string {
  if (!dbSchema || typeof dbSchema !== "object") return "";
  const schema = dbSchema as Record<string, unknown>;
  const tables = schema.tables as Array<Record<string, unknown>> | undefined;
  if (!Array.isArray(tables)) return "";
  return tables
    .map((t: Record<string, unknown>) => `| ${t.name as string} | D1 (${t.name as string} table) | id, tenant_id |`)
    .join("\n");
}

function extractCloudflareServices(techArch: Record<string, unknown> | null): string {
  if (!techArch) return "- D1, KV, R2 (standard foundation services)";
  const integrations = techArch.thirdPartyIntegrations as unknown[] ?? [];
  const services = [
    "- D1 (primary database)",
    "- KV (session, rate limit, cache)",
    "- R2 (file storage)",
    "- Workers AI (LLM inference)",
    "- Durable Objects (stateful agents)",
    "- Queues (async processing)",
    "- Cloudflare Pages (SvelteKit SSR)",
  ];
  if (integrations.length > 0) {
    services.push("", "Third-party integrations:", ...integrations.map((i) => `- ${typeof i === "string" ? i : stringify(i)}`));
  }
  return services.join("\n");
}

main().catch((e) => {
  console.error("[scaffold] Error:", e);
  process.exit(1);
});
